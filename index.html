<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Algoritmo A* em Tabuleiro (HTML + JS)</title>
    <style>
      :root {
        --bg: #0f172a;
        --panel: #111827;
        --accent: #22d3ee;
        --accent-2: #38bdf8;
        --grid: #1f2937;
        --path: #a3e635;
        --open: #60a5fa;
        --closed: #f472b6;
        --start: #34d399;
        --end: #f87171;
        --wall: #334155;
        --text: #e5e7eb;
        --muted: #9ca3af;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        background: linear-gradient(120deg, #0b1022, #0f172a);
        color: var(--text);
        display: grid;
        grid-template-rows: auto 1fr auto;
      }
      header {
        padding: 14px 16px;
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
        background: rgba(17, 24, 39, 0.85);
        backdrop-filter: blur(6px);
        border-bottom: 1px solid #111827;
      }
      header h1 {
        font-size: 16px;
        margin: 0;
        letter-spacing: 0.3px;
        color: #e2e8f0;
      }
      .controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      .controls > * {
        accent-color: var(--accent);
      }
      .btn {
        background: linear-gradient(180deg, var(--accent), var(--accent-2));
        color: #0b1022;
        border: none;
        padding: 8px 12px;
        border-radius: 10px;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 6px 18px rgba(34, 211, 238, 0.25);
      }
      .btn.secondary {
        background: #1f2937;
        color: var(--text);
        border: 1px solid #2b3647;
        box-shadow: none;
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .segmented {
        display: inline-flex;
        background: #0b1222;
        border: 1px solid #1e293b;
        padding: 4px;
        border-radius: 12px;
      }
      .segmented button {
        background: transparent;
        color: var(--text);
        border: 0;
        padding: 8px 10px;
        border-radius: 8px;
        cursor: pointer;
      }
      .segmented button.active {
        background: #172036;
        color: #e2e8f0;
        outline: 1px solid #243045;
      }
      .panel {
        display: grid;
        grid-template-columns: 280px 1fr;
        gap: 16px;
        padding: 16px;
        height: 100%;
      }
      @media (max-width: 980px) {
        .panel {
          grid-template-columns: 1fr;
        }
      }
      .sidebar {
        background: rgba(17, 24, 39, 0.65);
        border: 1px solid #1f2937;
        border-radius: 14px;
        padding: 14px;
      }
      .sidebar h2 {
        margin: 8px 0 12px;
        font-size: 14px;
        color: #93c5fd;
      }
      .sidebar .row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        align-items: center;
        margin-bottom: 10px;
      }
      .sidebar label {
        color: var(--muted);
        font-size: 12px;
      }
      .grid-wrap {
        background: rgba(17, 24, 39, 0.55);
        border: 1px solid #1f2937;
        border-radius: 14px;
        position: relative;
        overflow: clip;
        display: grid;
        place-items: center;
      }
      canvas {
        background: #0b0f1f;
        image-rendering: pixelated;
      }
      footer {
        padding: 10px 14px;
        color: var(--muted);
        font-size: 12px;
        text-align: center;
      }
      .legend {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
        margin-top: 12px;
      }
      .legend .item {
        display: flex;
        gap: 8px;
        align-items: center;
        font-size: 13px;
        color: #cbd5e1;
      }
      .swatch {
        width: 18px;
        height: 18px;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.35);
      }
    </style>
  </head>
  <body>
    <header>
      <h1>A* Pathfinding ‚Ä¢ Tabuleiro interativo</h1>
      <div class="controls">
        <div class="segmented" id="toolPicker" title="Ferramenta de edi√ß√£o">
          <button data-tool="wall" class="active">Paredes</button>
          <button data-tool="erase">Borracha</button>
          <button data-tool="start">In√≠cio</button>
          <button data-tool="end">Fim</button>
        </div>
        <button class="btn" id="runBtn">‚ñ∂ Executar A*</button>
        <button class="btn secondary" id="stepBtn">‚è≠ Passo</button>
        <button class="btn secondary" id="resetBtn">‚ü≤ Limpar</button>
        <button class="btn secondary" id="mazeBtn">üß© Aleatorizar paredes</button>
      </div>
    </header>

    <main class="panel">
      <aside class="sidebar">
        <h2>Configura√ß√µes</h2>
        <div class="row">
          <label for="size">Tamanho da grade (NxN)</label>
          <input type="range" id="size" min="10" max="60" value="30" />
        </div>
        <div class="row">
          <label for="speed">Velocidade (ms por passo)</label>
          <input type="range" id="speed" min="0" max="200" step="10" value="10" />
        </div>
        <div class="row">
          <label for="diag">Permitir diagonais</label>
          <input type="checkbox" id="diag" />
        </div>
        <div class="row">
          <label for="showCosts">Mostrar custos (g/h/f)</label>
          <input type="checkbox" id="showCosts" />
        </div>
        <div class="row">
          <label for="wBias">Dificultar (paredes %)</label>
          <input type="range" id="wBias" min="0" max="55" value="28" />
        </div>

        <h2>Legenda</h2>
        <div class="legend">
          <div class="item"><span class="swatch" style="background: var(--start)"></span>In√≠cio</div>
          <div class="item"><span class="swatch" style="background: var(--end)"></span>Fim</div>
          <div class="item"><span class="swatch" style="background: var(--wall)"></span>Parede</div>
          <div class="item"><span class="swatch" style="background: var(--open)"></span>Aberto</div>
          <div class="item"><span class="swatch" style="background: var(--closed)"></span>Fechado</div>
          <div class="item"><span class="swatch" style="background: var(--path)"></span>Caminho</div>
        </div>
      </aside>

      <section class="grid-wrap">
        <canvas id="board" width="840" height="840" aria-label="Tabuleiro A*" title="Clique para editar; arraste para pintar."></canvas>
      </section>
    </main>

    <footer>Clique para alternar paredes, ou selecione uma ferramenta acima (In√≠cio/Fim/Borracha). Arraste para pintar. Execute o A* para ver a busca.</footer>

    <script>
      // --- Utilidades ---
      const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
      const key = (r, c) => r + "," + c;

      // --- Estado global ---
      const canvas = document.getElementById("board");
      const ctx = canvas.getContext("2d");

      const state = {
        n: 30, // tamanho NxN
        start: { r: 2, c: 2 },
        end: { r: 27, c: 27 },
        walls: new Set(), // chaves "r,c"
        open: new Set(),
        closed: new Set(),
        path: new Set(),
        g: new Map(),
        f: new Map(),
        came: new Map(),
        running: false,
        prepared: false,
        diag: false,
        tool: "wall",
        cellSize: 0,
        dragging: false,
        drawVal: true, // usado ao arrastar: pintar ou apagar
        pq: [],
        timer: null,
        stepDelay: 10,
      };

      // --- UI ---
      const sizeInput = document.getElementById("size");
      const speedInput = document.getElementById("speed");
      const mazeBtn = document.getElementById("mazeBtn");
      const runBtn = document.getElementById("runBtn");
      const resetBtn = document.getElementById("resetBtn");
      const stepBtn = document.getElementById("stepBtn");
      const diagInput = document.getElementById("diag");
      const wBiasInput = document.getElementById("wBias");
      const showCostsInput = document.getElementById("showCosts");
      state.showCosts = false;

      showCostsInput.addEventListener("change", () => {
        state.showCosts = showCostsInput.checked;
        draw();
      });
      function setTool(t) {
        state.tool = t;
        document.querySelectorAll("#toolPicker button").forEach(b => {
          b.classList.toggle("active", b.dataset.tool === t);
        });
      }
      document.getElementById("toolPicker").addEventListener("click", e => {
        const b = e.target.closest("button");
        if (b) setTool(b.dataset.tool);
      });

      sizeInput.addEventListener("input", () => {
        resizeGrid(parseInt(sizeInput.value));
      });
      speedInput.addEventListener("input", () => {
        state.stepDelay = parseInt(speedInput.value);
      });
      diagInput.addEventListener("change", () => {
        state.diag = diagInput.checked;
        resetSearchOnly();
        draw();
      });

      runBtn.addEventListener("click", () => {
        if (state.running) {
          stopRun();
        } else {
          startRun();
        }
      });
      stepBtn.addEventListener("click", () => {
        if (state.running) return;
        if (!state.prepared) {
          prepareAStar();
          draw();
        }
        const cont = aStarStep();
        draw();
      });
      resetBtn.addEventListener("click", () => {
        resetSearchOnly();
        draw();
      });
      mazeBtn.addEventListener("click", () => {
        randomizeWalls();
        draw();
      });

      // --- Grid & desenho ---
      function resizeGrid(n) {
        state.n = n;
        state.walls.clear();
        // reposiciona in√≠cio/fim dentro do grid
        state.start.r = clamp(state.start.r, 0, n - 1);
        state.start.c = clamp(state.start.c, 0, n - 1);
        state.end.r = clamp(state.end.r, 0, n - 1);
        state.end.c = clamp(state.end.c, 0, n - 1);
        resetSearchOnly();
        draw();
      }

      function cellAt(x, y) {
        const size = Math.floor(Math.min(canvas.width, canvas.height) / state.n);
        state.cellSize = size;
        const c = clamp(Math.floor(x / size), 0, state.n - 1);
        const r = clamp(Math.floor(y / size), 0, state.n - 1);
        return { r, c };
      }

      function draw() {
        const N = state.n;
        const s = Math.floor(Math.min(canvas.width, canvas.height) / N);
        state.cellSize = s;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // fundo
        ctx.fillStyle = "#0b0f1f";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // pintar c√©lulas por estado
        for (let r = 0; r < N; r++) {
          for (let c = 0; c < N; c++) {
            const x = c * s,
              y = r * s;
            const k = key(r, c);

            if (state.walls.has(k)) {
              ctx.fillStyle = getCSS("--wall");
              ctx.fillRect(x, y, s, s);
            } else if (state.path.has(k)) {
              ctx.fillStyle = getCSS("--path");
              ctx.fillRect(x, y, s, s);
            } else if (state.closed.has(k)) {
              ctx.fillStyle = getCSS("--closed");
              ctx.fillRect(x, y, s, s);
            } else if (state.open.has(k)) {
              ctx.fillStyle = getCSS("--open");
              ctx.fillRect(x, y, s, s);
            }

            // contorno leve da c√©lula
            ctx.strokeStyle = "#12182a";
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 0.5, y + 0.5, s - 1, s - 1);

            // custos g/h/f (opcional)
            if (state.showCosts && !state.walls.has(k)) {
              const isSE = isStartOrEnd(r, c);
              // mostra apenas em c√©lulas envolvidas na busca (ou caminho), e n√£o em start/end
              if (!isSE && (state.open.has(k) || state.closed.has(k) || state.path.has(k))) {
                const g = state.g.get(k);
                const h = heuristic({ r, c }, state.end); // calcular h on-the-fly
                const f = (g !== undefined ? g : Infinity) + h;

                const cx = x + s / 2;
                // 3 linhas centralizadas
                drawText(cx, y + s * 0.3, `g:${g !== undefined ? g.toFixed(2) : "‚àû"}`, 10);
                drawText(cx, y + s * 0.5, `h:${h.toFixed(2)}`, 10);
                drawText(cx, y + s * 0.7, `f:${isFinite(f) ? f.toFixed(2) : "‚àû"}`, 10);
              }
            }
          }
        }

        // in√≠cio e fim no topo
        drawCell(state.start.r, state.start.c, getCSS("--start"));
        drawCell(state.end.r, state.end.c, getCSS("--end"));
      }

      function drawCell(r, c, color) {
        const s = state.cellSize;
        const x = c * s,
          y = r * s;
        ctx.fillStyle = color;
        ctx.fillRect(x, y, s, s);
        ctx.strokeStyle = "#0b0f1f";
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 0.5, y + 0.5, s - 1, s - 1);
      }

      function getCSS(v) {
        return getComputedStyle(document.documentElement).getPropertyValue(v).trim();
      }

      // --- Intera√ß√£o do mouse ---
      function applyTool(rc, isDrag = false) {
        const { r, c } = rc;
        const k = key(r, c);
        if (state.running) return;
        if (state.tool === "start") {
          state.start = { r, c };
          if (state.walls.has(k)) state.walls.delete(k);
        } else if (state.tool === "end") {
          state.end = { r, c };
          if (state.walls.has(k)) state.walls.delete(k);
        } else if (state.tool === "erase") {
          state.walls.delete(k);
        } else if (state.tool === "wall") {
          if (!isDrag) {
            // clique simples alterna
            if (state.walls.has(k)) state.walls.delete(k);
            else if (!isStartOrEnd(r, c)) state.walls.add(k);
          } else {
            // arraste usa drawVal para pintar/apagar continuamente
            if (state.drawVal) {
              if (!isStartOrEnd(r, c)) state.walls.add(k);
            } else {
              state.walls.delete(k);
            }
          }
        }
        resetSearchOnly();
        draw();
      }

      function isStartOrEnd(r, c) {
        return (r === state.start.r && c === state.start.c) || (r === state.end.r && c === state.end.c);
      }

      canvas.addEventListener("mousedown", e => {
        const rect = canvas.getBoundingClientRect();
        const rc = cellAt(e.clientX - rect.left, e.clientY - rect.top);
        state.dragging = true;
        // se clicar numa parede define drawVal; se n√£o, inverte
        state.drawVal = !state.walls.has(key(rc.r, rc.c));
        applyTool(rc);
      });
      canvas.addEventListener("mousemove", e => {
        if (!state.dragging) return;
        const rect = canvas.getBoundingClientRect();
        const rc = cellAt(e.clientX - rect.left, e.clientY - rect.top);
        applyTool(rc, true);
      });
      window.addEventListener("mouseup", () => {
        state.dragging = false;
      });

      // --- A* ---
      function heuristic(a, b) {
        const dx = Math.abs(a.c - b.c);
        const dy = Math.abs(a.r - b.r);
        if (!state.diag) return dx + dy; // Manhattan

        // Octile: D = 1 (reta), D2 = ‚àö2 (diagonal)
        const D = 1,
          D2 = Math.SQRT2;
        return D * (dx + dy) + (D2 - 2 * D) * Math.min(dx, dy);
      }

      function neighbors(r, c) {
        const dirs4 = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];
        const dirs8 = [
          [1, 1],
          [1, -1],
          [-1, 1],
          [-1, -1],
        ];
        const dirs = state.diag ? dirs4.concat(dirs8) : dirs4;
        const res = [];
        for (const [dr, dc] of dirs) {
          const nr = r + dr,
            nc = c + dc;
          if (nr < 0 || nc < 0 || nr >= state.n || nc >= state.n) continue;
          if (state.walls.has(key(nr, nc))) continue;
          const diagonal = dr !== 0 && dc !== 0;
          const cost = diagonal ? Math.SQRT2 : 1;
          res.push({ r: nr, c: nc, cost });
        }
        return res;
      }

      function resetSearchOnly() {
        state.open.clear();
        state.closed.clear();
        state.path.clear();
        state.g.clear();
        state.f.clear();
        state.came.clear();
        state.pq = [];
        state.running = false;
        state.prepared = false;
        runBtn.textContent = "‚ñ∂ Executar A*";
        if (state.timer) {
          clearInterval(state.timer);
          state.timer = null;
        }
      }

      function startRun() {
        resetSearchOnly();
        prepareAStar();
        state.running = true;
        runBtn.textContent = "‚èπ Parar";
        state.timer = setInterval(() => {
          const cont = aStarStep();
          if (!cont) stopRun();
          draw();
        }, state.stepDelay);
      }

      function stopRun() {
        state.running = false;
        runBtn.textContent = "‚ñ∂ Executar A*";
        if (state.timer) {
          clearInterval(state.timer);
          state.timer = null;
        }
        draw();
      }

      function prepareAStar() {
        const sK = key(state.start.r, state.start.c);
        state.g.set(sK, 0);
        state.f.set(sK, heuristic(state.start, state.end));
        pushPQ({ r: state.start.r, c: state.start.c, f: state.f.get(sK) });
        state.open.add(sK);
        state.prepared = true;
      }
      state.open.add(sK);

      function aStarStep() {
        if (state.pq.length === 0) return false; // terminou sem caminho
        const current = popPQ();
        const cK = key(current.r, current.c);
        if (!state.open.has(cK)) return true; // n√≥ stale, segue

        state.open.delete(cK);
        state.closed.add(cK);

        // Chegou no destino
        if (current.r === state.end.r && current.c === state.end.c) {
          reconstructPath();
          return false; // parou
        }

        for (const nb of neighbors(current.r, current.c)) {
          const nK = key(nb.r, nb.c);
          if (state.closed.has(nK)) continue;

          const tentativeG = (state.g.get(cK) ?? Infinity) + nb.cost;
          if (tentativeG < (state.g.get(nK) ?? Infinity)) {
            state.came.set(nK, cK);
            state.g.set(nK, tentativeG);
            const fVal = tentativeG + heuristic(nb, state.end);
            state.f.set(nK, fVal);
            pushPQ({ r: nb.r, c: nb.c, f: fVal });
            state.open.add(nK);
          }
        }
        return true; // continuar
      }

      function reconstructPath() {
        state.path.clear();
        let k = key(state.end.r, state.end.c);
        const sK = key(state.start.r, state.start.c);
        if (!state.came.has(k) && k !== sK) return; // sem caminho
        while (k && k !== sK) {
          state.path.add(k);
          k = state.came.get(k);
        }
        // n√£o pintar start
      }

      // --- Priority Queue simples (min-heap via array+sort) ---
      function pushPQ(node) {
        state.pq.push(node);
        // ordena por f crescente; custo O(n log n) ‚Äî suficiente para visualiza√ß√£o
        state.pq.sort((a, b) => a.f - b.f);
      }
      function popPQ() {
        return state.pq.shift();
      }

      // --- Paredes aleat√≥rias ---
      function randomizeWalls() {
        const bias = parseInt(wBiasInput.value); // % de paredes
        state.walls.clear();
        for (let r = 0; r < state.n; r++) {
          for (let c = 0; c < state.n; c++) {
            const k = key(r, c);
            if (isStartOrEnd(r, c)) continue;
            if (Math.random() * 100 < bias) state.walls.add(k);
          }
        }
        resetSearchOnly();
      }
      function drawText(x, y, text, size = 10, align = "center") {
        ctx.font = `${size}px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace`;
        ctx.textAlign = align;
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#e5e7eb";
        ctx.shadowColor = "rgba(0,0,0,.6)";
        ctx.shadowBlur = 2;
        ctx.fillText(text, x, y);
        ctx.shadowBlur = 0;
      }
      // --- Inicializa√ß√£o ---
      function init() {
        speedInput.value = state.stepDelay;
        showCostsInput.checked = state.showCosts;
        resizeGrid(state.n);
        // start/end default afastados
        state.start = { r: Math.floor(state.n * 0.08), c: Math.floor(state.n * 0.08) };
        state.end = { r: Math.floor(state.n * 0.9), c: Math.floor(state.n * 0.88) };
        draw();
        window.addEventListener("resize", () => {
          draw();
        });
      }

      init();
    </script>
  </body>
</html>
